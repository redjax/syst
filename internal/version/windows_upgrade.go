//go:build windows
// +build windows

package version

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"syscall"
)

// RunWindowsSelfUpgrade uses a batch file to replace the running executable on Windows
// Batch files are more compatible than PowerShell scripts (no execution policy issues)
func RunWindowsSelfUpgrade(oldExe, newExe string) error {
	// Get absolute paths
	absOldExe, err := filepath.Abs(oldExe)
	if err != nil {
		return fmt.Errorf("failed to get absolute path for old exe: %w", err)
	}
	absNewExe, err := filepath.Abs(newExe)
	if err != nil {
		return fmt.Errorf("failed to get absolute path for new exe: %w", err)
	}

	// Create a temporary batch file that will:
	//   - Wait for the current process to exit (using ping as a timer)
	//   - Replace the old exe with the new one (with retry logic)
	//   - Delete itself
	// Batch files always work regardless of PowerShell execution policies
	scriptContent := fmt.Sprintf(`@echo off
REM syst self-updater - Generated by syst.exe
REM Purpose: Replace old executable with new version after parent process exits

REM Wait 2 seconds for parent process to exit
ping 127.0.0.1 -n 3 >nul

REM Retry up to 10 times in case of file locks
set MAX_RETRIES=10
set RETRY_COUNT=0

:retry
move /Y "%s" "%s" >nul 2>&1
if %%ERRORLEVEL%% equ 0 (
    echo syst upgraded successfully.
    goto cleanup
)

set /a RETRY_COUNT=RETRY_COUNT+1
if %%RETRY_COUNT%% geq %%MAX_RETRIES%% (
    echo Failed to replace executable after %%MAX_RETRIES%% retries.
    goto end
)

REM Wait 500ms before retry
ping 127.0.0.1 -n 2 >nul
goto retry

:cleanup
REM Delete this batch file
del "%%~f0" >nul 2>&1

:end
`, absNewExe, absOldExe)

	// Write the script to a temporary file
	tmpScript, err := os.CreateTemp("", "syst-upgrade-*.bat")
	if err != nil {
		return fmt.Errorf("failed to create temp batch script: %w", err)
	}
	scriptPath := tmpScript.Name()

	if _, err := tmpScript.WriteString(scriptContent); err != nil {
		tmpScript.Close()
		os.Remove(scriptPath)
		return fmt.Errorf("failed to write batch script: %w", err)
	}
	tmpScript.Close()

	// Launch batch file in background (hidden window)
	// cmd.exe is always available on Windows and requires no special policies
	cmd := exec.Command("cmd.exe", "/C", "start", "/B", scriptPath)

	// Hide window to prevent console popup during background update
	cmd.SysProcAttr = &syscall.SysProcAttr{
		HideWindow:    true,
		CreationFlags: 0x08000000, // CREATE_NO_WINDOW
	}

	if err := cmd.Start(); err != nil {
		os.Remove(scriptPath)
		return fmt.Errorf("failed to start upgrade script: %w", err)
	}

	// Don't wait for the script to finish - it needs us to exit first
	return nil
}
